 package com.enterpriseQuestions;

 /**
 * @author MysteryGuest
 * @date 2021/11/09
 * 下面代码 public B(int m) { 这一行会报错
 * Implicit super constructor A() is undefined. Must explicitly invoke another constructor
 * 意思就父类已经定义了一个有参构造函数，你是人家儿子，你老爸都弄了个构造函数，
 * 你不得调用人家的构造函数呀，所以呀，子类应该通过super关键字显式地调用父类的有参构造函数。
 * 如果父类无有参构造函数，则子类继承父类就不会要求强制性地要求调用父类的构造函数，
 * 编译器会默认帮你调用父类的无参构造函数。
 */
public class ParentClass {
    public static void main(String[] args) {
        // 1_000_000等价于1000000，合法
        PB b = new PB(1_000_000);
        System.out.println(b.a);
//        System.out.println(1_000_000);
    }
}

class PA {
    int a;
    /**
     * 显式地定义无参构造方法，public B(int m) { 这一行将不报错
     * 因为子类构造方法中不写super()，它也会默认调用的是这个无参的构造方法
     * */
//    public PA() {
//        
//    }
    
    // 定义了一个新的构造方法
    public PA(int m) {
        a = 1000000;
    }
}

class PB extends PA {
    public PB(int m) {
        super(m);  // 显式的写出调用父类的有参构造方法，public B(int m) { 这一行将不报错
        a = 1;
    }
}

/**
 * 在Java中，子类的构造过程中，必须调用其父类的构造函数，是因为有继承关系存在时，
 * 子类要把父类的内容继承下来，通过什么手段做到的？ 
 * 
 * 答案如下：
 *  当你new一个子类对象的时候，必须首先要new一个父类的对像出来，
 *  这个父类对象位于子类对象的内部，所以说，子类对象比父类对象大，
 *  子类对象里面包含了一个父类的对象，这是内存中真实的情况。
 *  构造方法是new一个对象的时候，必须要调的方法，这是规定，要new父类对象出来，
 *  那么肯定要调用其构造方法，所以：
 *  
 *  第一个规则：
 *      子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，
 *      那么编译器会帮我们加上一个默认的构造方法，所谓默认的构造方法，
 *      就是没有参数的构造方法，但是如果你自己写了构造方法，那么编译器就不会给你添加了，
 *      所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，
 *      但是在子类构造方法中我们并没有显示的调用基类的构造方法，就是没写，
 *      如：super(); 并没有这样写，但是这样就会调用父类没有参数的构造方法，
 *      如果父类中没有没有参数的构造方法就会出错。
 *      
 *  第二个规则：
 *      如果子类的构造方法中没有显示的调用基类构造方法，
 *      则系统默认调用基类无参数的构造方法注意：
 *      如果子类的构造方法中既没有显示的调用基类构造方法，
 *      而基类中又没有默认无参的构造方法，则编译出错，所以，通常我们需要显示的：
 *      super(参数列表)，来调用父类有参数的构造函数。
 * */
